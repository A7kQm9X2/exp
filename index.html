<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pong (Simple)</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: rgba(255,255,255,0.06);
      --panel2: rgba(255,255,255,0.10);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --line: rgba(255,255,255,0.18);
      --accent: rgba(255,255,255,0.92);
      --shadow: 0 12px 36px rgba(0,0,0,0.35);
      --radius: 16px;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 700px at 20% 20%, #162033 0%, var(--bg) 50%, #070a0e 100%);
      color: var(--text);
      display: grid;
      place-items: center;
      padding: 16px;
      overflow: hidden;
    }

    .app {
      width: min(980px, 100%);
      display: grid;
      gap: 12px;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      padding: 12px 14px;
      border: 1px solid var(--line);
      background: linear-gradient(180deg, var(--panel), transparent);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    .title {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 200px;
    }
    .title .h {
      font-weight: 700;
      letter-spacing: 0.2px;
      font-size: 16px;
    }
    .title .sub {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.2;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    button, .chip {
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 999px;
      padding: 9px 12px;
      font-size: 13px;
      cursor: pointer;
      transition: transform 0.06s ease, background 0.15s ease, border-color 0.15s ease;
      user-select: none;
    }

    button:hover { background: rgba(255,255,255,0.10); border-color: rgba(255,255,255,0.25); }
    button:active { transform: translateY(1px); }
    button:focus-visible { outline: 2px solid rgba(255,255,255,0.35); outline-offset: 2px; }

    .chip {
      cursor: default;
      display: inline-flex;
      gap: 8px;
      align-items: center;
      padding: 9px 12px;
      background: rgba(255,255,255,0.05);
    }

    .chip b {
      font-variant-numeric: tabular-nums;
      letter-spacing: 0.3px;
    }

    .stage {
      border: 1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
      position: relative;
      backdrop-filter: blur(10px);
    }

    canvas {
      display: block;
      width: 100%;
      height: auto;
      aspect-ratio: 16 / 9;
      background: radial-gradient(800px 400px at 50% 40%, rgba(255,255,255,0.06) 0%, rgba(255,255,255,0) 55%),
                  linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      padding: 18px;
      pointer-events: none;
    }

    .card {
      pointer-events: none;
      width: min(520px, 92%);
      border: 1px solid var(--line);
      border-radius: 18px;
      background: rgba(10, 14, 20, 0.55);
      box-shadow: 0 16px 50px rgba(0,0,0,0.5);
      padding: 16px 16px 14px;
      text-align: center;
      backdrop-filter: blur(12px);
    }

    .card .big {
      font-size: 18px;
      font-weight: 800;
      letter-spacing: 0.2px;
      margin: 0 0 6px;
    }
    .card .small {
      margin: 0;
      font-size: 13px;
      color: var(--muted);
      line-height: 1.45;
    }

    .kbd {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      justify-content: center;
      margin-top: 10px;
      flex-wrap: wrap;
      color: var(--muted);
      font-size: 12px;
    }

    .key {
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.06);
      border-radius: 8px;
      padding: 4px 7px;
      font-variant-numeric: tabular-nums;
      color: rgba(255,255,255,0.85);
    }

    .footer-hint {
      text-align: center;
      font-size: 12px;
      color: var(--muted);
      margin-top: 2px;
    }

    @media (max-width: 640px) {
      header { padding: 10px 10px; }
      .title .h { font-size: 15px; }
      .title .sub { display: none; }
      button, .chip { padding: 8px 10px; font-size: 12px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="title">
        <div class="h">Pong (Simple)</div>
        <div class="sub">Keyboard or touch â€¢ First to 7 wins â€¢ Press Space to start/pause</div>
      </div>

      <div class="controls">
        <span class="chip">Score <b id="scoreText">0 : 0</b></span>
        <button id="btnStart">Start</button>
        <button id="btnPause">Pause</button>
        <button id="btnReset">Reset</button>
      </div>
    </header>

    <div class="stage">
      <canvas id="game" width="960" height="540" aria-label="Pong game canvas"></canvas>

      <div class="overlay" id="overlay" style="display:grid;">
        <div class="card">
          <p class="big" id="overlayTitle">Press Space to Start</p>
          <p class="small" id="overlayBody">
            You control the left paddle. The right paddle is AI.
            On touch devices, drag anywhere on the canvas to move your paddle.
          </p>
          <div class="kbd" aria-hidden="true">
            <span class="key">W</span>/<span class="key">S</span>
            <span style="opacity:.5">or</span>
            <span class="key">â†‘</span>/<span class="key">â†“</span>
            <span style="opacity:.5">â€¢</span>
            <span class="key">Space</span> Start/Pause
            <span style="opacity:.5">â€¢</span>
            <span class="key">R</span> Reset
          </div>
        </div>
      </div>
    </div>

    <div class="footer-hint" id="hint">
      Tip: If you lose the ball, it serves toward the player who was scored on.
    </div>
  </div>

  <script>
    (() => {
      // ---------- Canvas + scaling ----------
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d", { alpha: true });

      const scoreText = document.getElementById("scoreText");
      const overlay = document.getElementById("overlay");
      const overlayTitle = document.getElementById("overlayTitle");
      const overlayBody = document.getElementById("overlayBody");

      const btnStart = document.getElementById("btnStart");
      const btnPause = document.getElementById("btnPause");
      const btnReset = document.getElementById("btnReset");

      // Use logical units, then draw in those units.
      const W = canvas.width;
      const H = canvas.height;

      // ---------- Game state ----------
      const settings = {
        paddleW: 14,
        paddleH: 110,
        paddleInset: 26,
        paddleSpeed: 520,   // px/s
        aiMaxSpeed: 470,    // px/s
        aiLookahead: 0.18,  // seconds to "predict"
        ballRadius: 9,
        ballSpeed: 520,     // px/s baseline
        ballSpeedInc: 1.035, // multiplier on paddle hit
        maxBallSpeed: 980,
        scoreToWin: 7,
      };

      const state = {
        running: false,
        paused: false,
        gameOver: false,
        lastTime: 0,
        leftScore: 0,
        rightScore: 0,
        serveDir: 1, // 1 => to right, -1 => to left
        keys: new Set(),
        pointerActive: false,
      };

      const left = {
        x: settings.paddleInset,
        y: (H - settings.paddleH) / 2,
        vy: 0
      };

      const right = {
        x: W - settings.paddleInset - settings.paddleW,
        y: (H - settings.paddleH) / 2,
        vy: 0
      };

      const ball = {
        x: W / 2,
        y: H / 2,
        vx: 0,
        vy: 0,
        speed: settings.ballSpeed
      };

      function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

      function resetBall(servingDir) {
        // ServingDir is direction ball will travel on serve (1 => right, -1 => left)
        ball.x = W / 2;
        ball.y = H / 2;

        ball.speed = settings.ballSpeed;

        // Random angle within a safe range (avoid too vertical)
        const angle = (Math.random() * 0.9 - 0.45) * Math.PI; // ~[-81Â°, +81Â°] scaled down
        const base = ball.speed;

        const dx = Math.cos(angle) * base * servingDir;
        const dy = Math.sin(angle) * base;

        ball.vx = dx;
        ball.vy = dy;

        state.serveDir = servingDir;
      }

      function resetGame() {
        state.leftScore = 0;
        state.rightScore = 0;
        state.gameOver = false;
        state.running = false;
        state.paused = false;

        left.y = (H - settings.paddleH) / 2;
        right.y = (H - settings.paddleH) / 2;

        // Serve toward the last loser (start: serve to right)
        resetBall(1);

        updateScoreUI();
        showOverlay("Press Space to Start", "You control the left paddle. The right paddle is AI.\nTouch: drag on the canvas.");
        draw(); // render a clean static frame
      }

      function updateScoreUI() {
        scoreText.textContent = `${state.leftScore} : ${state.rightScore}`;
      }

      function showOverlay(title, body) {
        overlayTitle.textContent = title;
        overlayBody.textContent = body;
        overlay.style.display = "grid";
      }

      function hideOverlay() {
        overlay.style.display = "none";
      }

      function start() {
        if (state.gameOver) {
          resetGame();
        }
        if (!state.running) {
          state.running = true;
          state.paused = false;
          hideOverlay();
          state.lastTime = performance.now();
          requestAnimationFrame(loop);
        } else if (state.paused) {
          state.paused = false;
          hideOverlay();
          state.lastTime = performance.now();
          requestAnimationFrame(loop);
        }
      }

      function pause() {
        if (!state.running || state.gameOver) return;
        state.paused = true;
        showOverlay("Paused", "Press Space to resume.");
      }

      function togglePause() {
        if (!state.running) return start();
        if (state.gameOver) return;
        state.paused ? start() : pause();
      }

      // ---------- Input ----------
      function setLeftVelocityFromKeys() {
        const up = state.keys.has("w") || state.keys.has("arrowup");
        const down = state.keys.has("s") || state.keys.has("arrowdown");
        if (up && !down) left.vy = -settings.paddleSpeed;
        else if (down && !up) left.vy = settings.paddleSpeed;
        else left.vy = 0;
      }

      window.addEventListener("keydown", (e) => {
        const k = e.key.toLowerCase();

        if (k === " " || k === "spacebar") {
          e.preventDefault();
          togglePause();
          return;
        }
        if (k === "r") {
          e.preventDefault();
          resetGame();
          return;
        }
        if (["arrowup","arrowdown"].includes(k)) e.preventDefault();

        state.keys.add(k);
        setLeftVelocityFromKeys();
      });

      window.addEventListener("keyup", (e) => {
        const k = e.key.toLowerCase();
        state.keys.delete(k);
        setLeftVelocityFromKeys();
      });

      // Touch / pointer: drag anywhere on canvas to move left paddle
      function canvasToGameY(clientY) {
        const rect = canvas.getBoundingClientRect();
        const t = (clientY - rect.top) / rect.height;
        return clamp(t * H, 0, H);
      }

      function onPointerMove(e) {
        if (!state.pointerActive) return;
        const y = canvasToGameY(e.clientY);
        left.y = clamp(y - settings.paddleH / 2, 0, H - settings.paddleH);
        left.vy = 0;
      }

      canvas.addEventListener("pointerdown", (e) => {
        canvas.setPointerCapture?.(e.pointerId);
        state.pointerActive = true;
        onPointerMove(e);
      });

      canvas.addEventListener("pointermove", onPointerMove);

      function endPointer(e) {
        state.pointerActive = false;
      }
      canvas.addEventListener("pointerup", endPointer);
      canvas.addEventListener("pointercancel", endPointer);
      canvas.addEventListener("pointerleave", endPointer);

      // Buttons
      btnStart.addEventListener("click", start);
      btnPause.addEventListener("click", togglePause);
      btnReset.addEventListener("click", resetGame);

      // ---------- Physics helpers ----------
      function circleRectCollision(cx, cy, r, rx, ry, rw, rh) {
        const closestX = clamp(cx, rx, rx + rw);
        const closestY = clamp(cy, ry, ry + rh);
        const dx = cx - closestX;
        const dy = cy - closestY;
        return (dx * dx + dy * dy) <= (r * r);
      }

      function reflectBallOffPaddle(paddle) {
        // Move ball out of paddle to avoid sticking
        if (paddle === left) ball.x = left.x + settings.paddleW + settings.ballRadius + 0.5;
        else ball.x = right.x - settings.ballRadius - 0.5;

        // Where on paddle did it hit? (-1 top .. +1 bottom)
        const paddleCenter = paddle.y + settings.paddleH / 2;
        const rel = clamp((ball.y - paddleCenter) / (settings.paddleH / 2), -1, 1);

        // Convert rel into a reflection angle (max ~50 deg)
        const maxAngle = 50 * Math.PI / 180;
        const angle = rel * maxAngle;

        // Ensure ball goes toward the other side
        const dir = (paddle === left) ? 1 : -1;

        // Increase speed slightly on each hit (cap it)
        ball.speed = Math.min(settings.maxBallSpeed, ball.speed * settings.ballSpeedInc);

        // New velocity based on angle and speed
        const vx = Math.cos(angle) * ball.speed * dir;
        const vy = Math.sin(angle) * ball.speed;

        ball.vx = vx;
        // Add some of paddle velocity influence (a little "spin")
        ball.vy = vy + paddle.vy * 0.15;
      }

      // ---------- Update ----------
      function update(dt) {
        // Left paddle (keyboard)
        setLeftVelocityFromKeys();
        left.y = clamp(left.y + left.vy * dt, 0, H - settings.paddleH);

        // Right paddle (simple AI)
        const targetY = (() => {
          // Predict ball's y a short time ahead, only if ball is moving toward AI
          if (ball.vx > 0) return ball.y + ball.vy * settings.aiLookahead;
          // If ball moving away, drift toward center
          return H / 2;
        })();

        const rightCenter = right.y + settings.paddleH / 2;
        const diff = targetY - rightCenter;
        const desiredVy = clamp(diff * 7.0, -settings.aiMaxSpeed, settings.aiMaxSpeed); // proportional controller
        right.vy = desiredVy;
        right.y = clamp(right.y + right.vy * dt, 0, H - settings.paddleH);

        // Ball movement
        ball.x += ball.vx * dt;
        ball.y += ball.vy * dt;

        // Top/bottom wall bounce
        if (ball.y - settings.ballRadius <= 0) {
          ball.y = settings.ballRadius;
          ball.vy *= -1;
        } else if (ball.y + settings.ballRadius >= H) {
          ball.y = H - settings.ballRadius;
          ball.vy *= -1;
        }

        // Paddle collisions
        const leftHit = circleRectCollision(
          ball.x, ball.y, settings.ballRadius,
          left.x, left.y, settings.paddleW, settings.paddleH
        );
        if (leftHit && ball.vx < 0) reflectBallOffPaddle(left);

        const rightHit = circleRectCollision(
          ball.x, ball.y, settings.ballRadius,
          right.x, right.y, settings.paddleW, settings.paddleH
        );
        if (rightHit && ball.vx > 0) reflectBallOffPaddle(right);

        // Score checks
        if (ball.x + settings.ballRadius < 0) {
          // Right scores
          state.rightScore += 1;
          updateScoreUI();
          if (state.rightScore >= settings.scoreToWin) {
            endGame(false);
          } else {
            // Serve toward left (loser was left)
            resetBall(-1);
          }
        } else if (ball.x - settings.ballRadius > W) {
          // Left scores
          state.leftScore += 1;
          updateScoreUI();
          if (state.leftScore >= settings.scoreToWin) {
            endGame(true);
          } else {
            // Serve toward right (loser was right)
            resetBall(1);
          }
        }
      }

      function endGame(leftWon) {
        state.gameOver = true;
        state.running = false;
        state.paused = false;
        showOverlay(
          leftWon ? "You win! ðŸŽ‰" : "AI wins!",
          "Press R to reset, or Space to start a new match."
        );
      }

      // ---------- Draw ----------
      function drawNet() {
        const dashH = 18;
        const gap = 14;
        const x = W / 2;
        ctx.save();
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = "rgba(255,255,255,0.35)";
        for (let y = 18; y < H - 18; y += dashH + gap) {
          ctx.fillRect(x - 2, y, 4, dashH);
        }
        ctx.restore();
      }

      function drawPaddle(p) {
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.92)";
        ctx.fillRect(p.x, p.y, settings.paddleW, settings.paddleH);
        ctx.restore();
      }

      function drawBall() {
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, settings.ballRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      function drawScoreOnCanvas() {
        ctx.save();
        ctx.globalAlpha = 0.42;
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.font = "900 72px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        const padTop = 18;
        ctx.fillText(String(state.leftScore), W * 0.42, padTop);
        ctx.fillText(String(state.rightScore), W * 0.58, padTop);
        ctx.restore();
      }

      function draw() {
        ctx.clearRect(0, 0, W, H);

        // subtle vignette
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.12)";
        ctx.fillRect(0, 0, W, H);
        ctx.restore();

        drawNet();
        drawPaddle(left);
        drawPaddle(right);
        drawBall();
        drawScoreOnCanvas();
      }

      // ---------- Loop ----------
      function loop(t) {
        if (!state.running || state.paused || state.gameOver) {
          draw();
          return;
        }

        const dt = Math.min(0.033, (t - state.lastTime) / 1000); // cap dt for stability
        state.lastTime = t;

        update(dt);
        draw();

        requestAnimationFrame(loop);
      }

      // ---------- Initialize ----------
      resetGame();

      // Space to start works even if canvas isn't focused (handled on window keydown).
      // Make sure overlay text stays correct on load.
      showOverlay("Press Space to Start", "You control the left paddle. The right paddle is AI.\nTouch: drag on the canvas.");
    })();
  </script>
</body>
</html>
